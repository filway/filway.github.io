import{g as e,f as r,G as a}from"./common-bec3f312.js";const o='{"title":"Webpack基础以及Loader和Plugin","frontmatter":{"date":"2022-08-09","title":"Webpack基础以及Loader和Plugin","tags":["vue-cli","webpack","nginx","项目优化"],"describe":"优化的手段的本质就是 减少代码体积 加快响应速度"},"headers":[{"level":2,"title":"Webpack 构建优化","slug":"webpack-构建优化"},{"level":3,"title":"loaders 的原理","slug":"loaders-的原理"},{"level":3,"title":"Plugins 的原理","slug":"plugins-的原理"}],"relativePath":"docs/notes/Performance/03.md","lastUpdated":1660147426756.5005}';var t={};const p=a('<h2 id="webpack-构建优化"><a class="header-anchor" href="#webpack-构建优化" aria-hidden="true">#</a> Webpack 构建优化</h2><h4 id="bundler-打包工具"><a class="header-anchor" href="#bundler-打包工具" aria-hidden="true">#</a> Bundler - 打包工具</h4><p>将浏览器不支持的模块进行编译，转换，合并最后生成的代码可以在浏览器端良好的运行的工具。</p><p><strong>Loader</strong><a href="https://webpack.docschina.org/concepts/loaders/" target="_blank" rel="noopener noreferrer">https://webpack.docschina.org/concepts/loaders/</a></p><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或 “load(加载)” 模块时预处理文件。</p><p><strong>多个 Loader</strong> module.rules 允许你在 webpack 配置中指定多个 loader。 这种方式是展示 loader 的一种简明方式，并且有助于使代码变得简洁和易于维护。</p><p><strong>plugins</strong><a href="https://webpack.docschina.org/concepts/plugins/" target="_blank" rel="noopener noreferrer">https://webpack.docschina.org/concepts/plugins/</a></p><p>插件是 webpack 的 支柱 功能。webpack 自身也是构建于你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。（我自己的理解，loader 解决的是各种不同资源的问题，plugins 更多解决的是项目整体的事情）</p><h3 id="loaders-的原理"><a class="header-anchor" href="#loaders-的原理" aria-hidden="true">#</a> loaders 的原理</h3><p><strong>在 loader 内部获取它的选项</strong></p><p>使用 <a href="https://github.com/webpack/loader-utils" target="_blank" rel="noopener noreferrer">https://github.com/webpack/loader-utils</a> 这个webpack 官方的 loader 的第三方工具库。</p><p><strong>Marked.js 的配置选项</strong><a href="https://marked.js.org/using_advanced" target="_blank" rel="noopener noreferrer">https://marked.js.org/using_advanced</a></p><p><strong>多个 Loader 串联</strong></p><ul><li>最后的 loader 最早调用，将会传入原始资源内容。</li><li>第一个 loader 最后调用，期望值是传出 JavaScript 和 source map（可选）。</li><li>中间的 loader 执行时，会传入前一个 loader 传出的结果。</li></ul><p><strong>将 markdown 转换为 html：turndown</strong> 地址：<a href="https://github.com/domchristie/turndown" target="_blank" rel="noopener noreferrer">https://github.com/domchristie/turndown</a></p><h3 id="plugins-的原理"><a class="header-anchor" href="#plugins-的原理" aria-hidden="true">#</a> Plugins 的原理</h3><p><strong>Loaders 关注代码中的单个资源，Plugins 关注整体流程，可以接触到 webpack 构建流程中的各个阶段并劫持做一些代码处理。</strong></p><p>官方的教程：<a href="https://webpack.js.org/contribute/writing-a-plugin/" target="_blank" rel="noopener noreferrer">https://webpack.js.org/contribute/writing-a-plugin/</a></p><p><strong>插件的格式</strong></p><ul><li>一个 JavaScript 函数或 JavaScript 类</li><li>在它原型上定义的 apply 方法，会在安装插件时被调用，并被 webpack compiler 调用一次</li><li>指定一个触及到 webpack 本身的事件钩子，即 hooks，用于特定时机处理额外的逻辑</li></ul><p><strong>Compiler Hooks 列表</strong><a href="https://webpack.js.org/api/compiler-hooks/" target="_blank" rel="noopener noreferrer">https://webpack.js.org/api/compiler-hooks/</a></p><p><strong>Compilation Hooks</strong><a href="https://webpack.js.org/api/compilation-hooks/" target="_blank" rel="noopener noreferrer">https://webpack.js.org/api/compilation-hooks/</a></p>',22);t.render=function(a,o,t,n,s,l){return r(),e("div",null,[p])};export default t;export{o as __pageData};
