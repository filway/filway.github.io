import{g as e,f as l,G as o}from"./common-bec3f312.js";const a='{"title":"脚手架的实现原理","frontmatter":{"date":"2022-04-03","title":"脚手架的实现原理","tags":["前端架构师","week2","脚手架"],"describe":null},"headers":[{"level":2,"title":"脚手架实现原理","slug":"脚手架实现原理"},{"level":2,"title":"脚手架原理进阶","slug":"脚手架原理进阶"}],"relativePath":"docs/Front_arch/week2/03.md","lastUpdated":1660147426752.5005}';var n={};const d=o('<h2 id="脚手架实现原理"><a class="header-anchor" href="#脚手架实现原理" aria-hidden="true">#</a> 脚手架实现原理</h2><p>如果你能回答以下 <strong>3</strong> 个问题，就掌握了脚手架的实现原理：</p><ul><li>为什么全局安装 <code>@vue/cli</code> 后会添加的命令为 <code>vue</code>？</li></ul><div class="language-bash"><pre><code><span class="token function">npm</span> <span class="token function">install</span> -g @vue/cli\n</code></pre></div><ul><li>全局安装 <code>@vue/cli</code> 时发生了什么？</li><li>执行 <code>vue</code> 命令时发生了什么？为什么 <code>vue</code> 指向一个 <code>js</code> 文件，我们却可以直接通过 <code>vue</code> 命令去执行它？</li></ul><h2 id="脚手架原理进阶"><a class="header-anchor" href="#脚手架原理进阶" aria-hidden="true">#</a> 脚手架原理进阶</h2><p>掌握上节内容后，我们可以继续尝试回答以下 <strong>2</strong> 个问题：</p><ul><li>为什么说脚手架本质是操作系统的客户端？它和我们在PC上安装的应用/软件有什么区别？</li><li>如何为 <code>node</code> 脚手架命令创建别名？</li><li>描述脚手架命令执行的全过程。</li></ul><p><img src="https://oss.filway.cn/filway-blog/5fda206309ec25b223221949.jpg" alt="图片描述"></p><p>扩展一下，有的同学可能会问下面两种写法的区别？</p><div class="language-bash"><pre><code><span class="token shebang important">#!/usr/bin/env node</span>\n<span class="token comment">#!/usr/bin/node</span>\n</code></pre></div><ul><li>第一种是在环境变量中查找 <code>node</code></li><li>第二种是直接执行 <code>/usr/bin/</code> 目录下的 <code>node</code></li></ul>',12);n.render=function(o,a,n,c,s,i){return l(),e("div",null,[d])};export default n;export{a as __pageData};
