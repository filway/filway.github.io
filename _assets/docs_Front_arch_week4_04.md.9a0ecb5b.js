import{g as e,f as l,G as i}from"./common-bec3f312.js";const a='{"title":"Node多进程开发进阶","frontmatter":{"date":"2022-04-07","title":"Node多进程开发进阶","tags":["前端架构师","week4","脚手架","Node","多进程"],"describe":null},"headers":[{"level":2,"title":"疑问和收获","slug":"疑问和收获"},{"level":2,"title":"Node 多进程源码总结","slug":"node-多进程源码总结"},{"level":2,"title":"exec 源码深入分析","slug":"exec-源码深入分析"},{"level":2,"title":"Node 多进程回调流程","slug":"node-多进程回调流程"},{"level":2,"title":"Node 多进程执行阶段总结","slug":"node-多进程执行阶段总结"},{"level":2,"title":"Fork 执行流程分析","slug":"fork-执行流程分析"},{"level":2,"title":"同步方法源码分析","slug":"同步方法源码分析"},{"level":2,"title":"知识储备","slug":"知识储备"},{"level":3,"title":"shell的使用","slug":"shell的使用"}],"relativePath":"docs/Front_arch/week4/04.md","lastUpdated":1660147426756.5005}';var s={};const r=i('<h2 id="疑问和收获"><a class="header-anchor" href="#疑问和收获" aria-hidden="true">#</a> 疑问和收获</h2><ul><li>exec 和 execFile 到底有什么区别？</li><li>为什么 exec/execFile/fork 都是通过 spawn 实现的，spawn 的作用到底是什么？</li><li>为什么 spawn 调用后没有回调，而 exec 和 execFile 能够回调？</li><li>为什么 spawn 调用后需要手动调用 child.stdout.on(‘data’, callback)，这里的 child.stdout / child.stderr 到底是什么？</li><li>为什么有 data/error/exit/close 这么多种回调，它们的执行顺序到底是怎样的？</li></ul><h2 id="node-多进程源码总结"><a class="header-anchor" href="#node-多进程源码总结" aria-hidden="true">#</a> Node 多进程源码总结</h2><ul><li>exec/execFile/spawn/fork的区别 <ul><li>exec：原理是调用 /bin/sh -c 执行我们传入的 shell 脚本，底层调用了 execFile</li><li>execFile：原理是直接执行我们传入的 file 和 args，底层调用 spawn 创建和执行子进程，并建立了回调，一次性将所有的 stdout 和 stderr 结果返回</li><li>spawn：原理是调用了 internal/child_process，实例化了 ChildProcess 子进程对象，再调用 child.spawn 创建子进程并执行命令，底层是调用了 child._handle.spawn 执行 process_wrap 中的 spawn 方法，执行过程是异步的，执行完毕后通过 PIPE 进行单向数据通信，通信结束后会子进程发起 onexit 回调，同时 Socket 会执行 close 回调</li><li>fork：原理是通过 spawn 创建子进程和执行命令，采用 node 执行命令，通过 setupchannel 创建 IPC 用于子进程和父进程之间的双向通信</li></ul></li><li>data/error/exit/close回调的区别 <ul><li>data：主进程读取数据过程中通过 onStreamRead 发起的回调</li><li>error：命令执行失败后发起的回调</li><li>exit：子进程关闭完成后发起的回调</li><li>close：子进程所有 Socket 通信端口全部关闭后发起的回调</li><li>stdout close/stderr close：特定的 PIPE 读取完成后调用 onReadableStreamEnd 关闭 Socket 时发起的回调</li></ul></li></ul><h2 id="exec-源码深入分析"><a class="header-anchor" href="#exec-源码深入分析" aria-hidden="true">#</a> exec 源码深入分析</h2><ul><li>child_process <ul><li>exec</li><li>execFile</li><li>spawn</li></ul></li><li>internal/child_process <ul><li>ChildProcess</li><li>spawn</li></ul></li></ul><p><img src="https://oss.filway.cn/filway-blog/5fe4a45008e8401916001488.jpg" alt="exec"></p><h2 id="node-多进程回调流程"><a class="header-anchor" href="#node-多进程回调流程" aria-hidden="true">#</a> Node 多进程回调流程</h2><ul><li>spawn</li><li>Pipe</li><li>onexit</li><li>kill</li><li>Socket</li><li>close</li><li>exit</li></ul><p><img src="https://oss.filway.cn/filway-blog/5fe4a466088f524d11521434.jpg" alt="callback"></p><h2 id="node-多进程执行阶段总结"><a class="header-anchor" href="#node-多进程执行阶段总结" aria-hidden="true">#</a> Node 多进程执行阶段总结</h2><p><img src="https://oss.filway.cn/filway-blog/5fe4a47508628fd714141060.jpg" alt="process"></p><h2 id="fork-执行流程分析"><a class="header-anchor" href="#fork-执行流程分析" aria-hidden="true">#</a> Fork 执行流程分析</h2><p>核心区别是创建 IPC Channel 取代 [stdin, stdout, stderr]</p><h2 id="同步方法源码分析"><a class="header-anchor" href="#同步方法源码分析" aria-hidden="true">#</a> 同步方法源码分析</h2><p>核心是调用 Process.spawnSync</p><h2 id="知识储备"><a class="header-anchor" href="#知识储备" aria-hidden="true">#</a> 知识储备</h2><h3 id="shell的使用"><a class="header-anchor" href="#shell的使用" aria-hidden="true">#</a> shell的使用</h3><p>方法一：直接执行shell文件</p><div class="language-bash"><pre><code>/bin/sh test.shell\n</code></pre></div><p>方法二：直接执行shell语句</p><div class="language-bash"><pre><code>/bin/sh -c <span class="token string">&quot;ls -al|grep node_modules&quot;</span>\n</code></pre></div>',22);s.render=function(i,a,s,d,t,o){return l(),e("div",null,[r])};export default s;export{a as __pageData};
